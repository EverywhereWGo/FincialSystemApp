# Android个人理财系统项目分析

## 1. 项目总体架构

Android个人理财系统采用了清晰的分层架构设计，遵循MVVM架构模式，主要包含以下几层：

1. **表现层 (UI层)**
   - 位于`ui`包下，包含Activity、Fragment和Adapter
   - 负责用户界面展示和用户交互逻辑

2. **业务逻辑层 (Repository层)**
   - 位于`repository`包下
   - 负责连接UI层和数据层，处理业务逻辑
   - 协调网络请求和本地数据库操作

3. **数据访问层 (DAO层)**
   - 位于`db/dao`包下
   - 提供对本地SQLite数据库的CRUD操作

4. **模型层 (Model层)**
   - 位于`model`包下
   - 定义数据实体类

5. **网络层 (Network层)**
   - 位于`network`包下
   - 处理网络请求和响应
   - 包含Mock接口实现，模拟后端服务

6. **工具层 (Utils层)**
   - 位于`utils`包下
   - 提供各种辅助工具类和方法

## 2. 模块详细分析

### 2.1 用户认证与管理模块

#### 2.1.1 核心功能与方法

**LoginActivity**
- `login()`: 处理用户登录逻辑
- `handleLoginSuccess()`: 处理登录成功后的操作
- `saveUserToLocalDb()`: 将用户信息保存到本地数据库
- `saveLoginHistory()`: 记录用户登录历史

代码示例：
```java
private void login() {
    // 获取输入
    String username = binding.etUsername.getText().toString().trim();
    String password = binding.etPassword.getText().toString().trim();
    
    // 验证输入
    if (TextUtils.isEmpty(username)) {
        binding.etUsername.setError(getString(R.string.field_required));
        return;
    }
    
    // 使用仓库层登录
    userRepository.login(username, password, new RepositoryCallback<LoginResponse>() {
        @Override
        public void onSuccess(LoginResponse loginResponse) {
            // 处理登录成功
            handleLoginSuccess(loginResponse);
        }
        
        @Override
        public void onError(String error) {
            // 处理登录失败
            handleLoginFailure(error);
        }
    });
}
```

**UserRepository**
- `login()`: 发起登录请求
- `register()`: 发起注册请求
- `getUserInfo()`: 获取用户信息
- `updateUserInfo()`: 更新用户信息
- `changePassword()`: 修改密码

代码示例：
```java
public void login(String username, String password, final RepositoryCallback<LoginResponse> callback) {
    // 检查网络状态
    if (!NetworkUtils.isNetworkAvailable(context)) {
        callback.onError("无网络连接，无法登录");
        return;
    }
    
    // 创建登录请求
    LoginRequest request = new LoginRequest(username, password);
    request.setDeviceInfo(DeviceUtils.getDeviceInfo());
    
    // 发起登录请求
    apiService.login(request).enqueue(new Callback<ApiResponse<LoginResponse>>() {
        // 处理响应...
    });
}
```

**UserDao**
- `insert()`: 插入用户记录
- `update()`: 更新用户记录
- `queryByUsername()`: 根据用户名查询用户
- `queryByPhone()`: 根据手机号查询用户
- `updatePassword()`: 更新用户密码
- `incrementFailedAttempts()`: 增加登录失败次数
- `lockAccount()`: 锁定账户

代码示例：
```java
public long insert(User user) {
    try {
        ContentValues values = new ContentValues();
        values.put("username", user.getUsername());
        values.put("phone", user.getPhone());
        values.put("email", user.getEmail());
        values.put("password", user.getPassword());
        values.put("role", user.getRole());
        values.put("created_at", user.getCreatedAt());
        values.put("updated_at", user.getUpdatedAt());
        
        // 更多字段...
        
        return database.insert(TABLE_NAME, null, values);
    } catch (Exception e) {
        LogUtils.e("Insert user error: " + e.getMessage());
        return -1;
    }
}
```

#### 2.1.2 安全机制

- **密码存储**：采用SHA-256加盐哈希存储
- **登录失败限制**：5次失败后锁定账户15分钟
- **Token安全**：使用JWT Token，有效期控制
- **登录历史记录**：记录用户登录时间、IP地址、设备信息
- **数据库加密**：使用SQLCipher进行AES-256加密

代码示例：
```java
// SecurityUtils中的密码校验
public static boolean checkPassword(String inputPassword, String storedHash, String salt) {
    String calculatedHash = hashPassword(inputPassword, salt);
    return calculatedHash.equals(storedHash);
}

// 登录失败处理
public void handleLoginAttempt(String username, boolean success) {
    User user = queryByUsername(username);
    if (user != null) {
        if (success) {
            user.resetFailedAttempts();
        } else {
            user.incrementFailedAttempts();
            if (user.getFailedAttempts() >= 5) {
                Calendar calendar = Calendar.getInstance();
                calendar.add(Calendar.MINUTE, 15);
                user.setLockedUntil(calendar.getTime());
            }
            update(user);
        }
    }
}
```

### 2.2 交易记录模块

#### 2.2.1 核心功能与方法

**TransactionRepository**
- `addTransaction()`: 添加交易记录
- `getTransactionList()`: 获取交易记录列表
- `getTransactionDetail()`: 获取交易详情
- `updateTransaction()`: 更新交易记录
- `deleteTransaction()`: 删除交易记录

代码示例：
```java
public void addTransaction(AddTransactionRequest request, RepositoryCallback<Transaction> callback) {
    // 检查网络
    if (!NetworkUtils.isNetworkAvailable(context)) {
        // 保存到本地数据库，待网络恢复后同步
        Transaction transaction = convertRequestToTransaction(request);
        transaction.setSyncState(Transaction.SYNC_STATE_LOCAL);
        transaction.setCreatedAt(System.currentTimeMillis());
        transaction.setUpdatedAt(System.currentTimeMillis());
        
        long id = databaseManager.getTransactionDao().insert(transaction);
        if (id > 0) {
            transaction.setId(id);
            callback.onSuccess(transaction);
        } else {
            callback.onError("添加交易记录失败");
        }
        return;
    }
    
    // 网络请求
    apiService.addTransaction(request).enqueue(/* ... */);
}
```

**TransactionDao**
- `insert()`: 插入交易记录
- `update()`: 更新交易记录
- `delete()`: 删除交易记录
- `queryById()`: 根据ID查询交易记录
- `queryByDateRange()`: 根据日期范围查询交易记录
- `queryByCategory()`: 根据分类查询交易记录
- `queryByType()`: 根据类型(收入/支出)查询交易记录
- `queryForStatistics()`: 查询统计数据

代码示例：
```java
public List<Transaction> queryByDateRange(long startTime, long endTime, int type) {
    List<Transaction> transactions = new ArrayList<>();
    String selection = "created_at BETWEEN ? AND ?";
    String[] selectionArgs;
    
    if (type > 0) {
        selection += " AND type = ?";
        selectionArgs = new String[]{
                String.valueOf(startTime),
                String.valueOf(endTime),
                String.valueOf(type)
        };
    } else {
        selectionArgs = new String[]{
                String.valueOf(startTime),
                String.valueOf(endTime)
        };
    }
    
    Cursor cursor = null;
    try {
        cursor = database.query(TABLE_NAME, null, selection, selectionArgs, null, null, "created_at DESC");
        while (cursor != null && cursor.moveToNext()) {
            transactions.add(cursorToTransaction(cursor));
        }
    } catch (Exception e) {
        LogUtils.e("Query transaction by date range error: " + e.getMessage());
    } finally {
        closeCursor(cursor);
    }
    
    return transactions;
}
```

#### 2.2.2 交易记录UI

**AddTransactionActivity**
- `initViews()`: 初始化界面
- `setupDatePicker()`: 设置日期选择器
- `setupCategorySpinner()`: 设置分类选择器
- `validateAndSaveTransaction()`: 验证并保存交易记录
- `attachImage()`: 附加票据图片

代码示例：
```java
private void validateAndSaveTransaction() {
    // 验证输入
    String amountStr = binding.etAmount.getText().toString().trim();
    if (TextUtils.isEmpty(amountStr)) {
        binding.etAmount.setError(getString(R.string.field_required));
        return;
    }
    
    double amount = Double.parseDouble(amountStr);
    if (amount <= 0) {
        binding.etAmount.setError(getString(R.string.amount_must_greater_than_zero));
        return;
    }
    
    // 创建请求
    AddTransactionRequest request = new AddTransactionRequest();
    request.setAmount(amount);
    request.setType(selectedType);
    request.setCategoryId(selectedCategory.getId());
    request.setNote(binding.etNote.getText().toString().trim());
    request.setTransactionTime(selectedDate.getTime());
    
    // 添加附件
    if (selectedImagePath != null) {
        request.setImagePath(selectedImagePath);
    }
    
    // 保存交易记录
    transactionRepository.addTransaction(request, new RepositoryCallback<Transaction>() {
        @Override
        public void onSuccess(Transaction transaction) {
            Toast.makeText(AddTransactionActivity.this, R.string.add_transaction_success, Toast.LENGTH_SHORT).show();
            finish();
        }
        
        @Override
        public void onError(String error) {
            Toast.makeText(AddTransactionActivity.this, error, Toast.LENGTH_SHORT).show();
        }
    });
}
```

### 2.3 预算管理模块

#### 2.3.1 核心功能与方法

**BudgetRepository**
- `addBudget()`: 添加预算
- `updateBudget()`: 更新预算
- `deleteBudget()`: 删除预算
- `getBudgetList()`: 获取预算列表
- `getBudgetProgress()`: 获取预算进度
- `checkBudgetWarning()`: 检查预算超支警告

代码示例：
```java
public void getBudgetProgress(long budgetId, RepositoryCallback<BudgetProgress> callback) {
    // 获取预算
    Budget budget = databaseManager.getBudgetDao().queryById(budgetId);
    if (budget == null) {
        callback.onError("预算不存在");
        return;
    }
    
    // 计算当前月份的消费
    Calendar calendar = Calendar.getInstance();
    calendar.set(Calendar.DAY_OF_MONTH, 1);
    calendar.set(Calendar.HOUR_OF_DAY, 0);
    calendar.set(Calendar.MINUTE, 0);
    calendar.set(Calendar.SECOND, 0);
    calendar.set(Calendar.MILLISECOND, 0);
    long startOfMonth = calendar.getTimeInMillis();
    
    calendar.add(Calendar.MONTH, 1);
    long endOfMonth = calendar.getTimeInMillis() - 1;
    
    double spent = databaseManager.getTransactionDao().getSumByCategory(
            budget.getCategoryId(), startOfMonth, endOfMonth, Transaction.TYPE_EXPENSE);
    
    // 计算进度
    BudgetProgress progress = new BudgetProgress();
    progress.setBudget(budget);
    progress.setSpent(spent);
    progress.setRemaining(budget.getAmount() - spent);
    progress.setProgress(spent / budget.getAmount() * 100);
    
    callback.onSuccess(progress);
}
```

**BudgetDao**
- `insert()`: 插入预算
- `update()`: 更新预算
- `delete()`: 删除预算
- `queryById()`: 根据ID查询预算
- `queryByMonth()`: 根据月份查询预算
- `queryByCategory()`: 根据分类查询预算

代码示例：
```java
public List<Budget> queryByMonth(int year, int month) {
    List<Budget> budgets = new ArrayList<>();
    String selection = "year = ? AND month = ?";
    String[] selectionArgs = new String[]{String.valueOf(year), String.valueOf(month)};
    
    Cursor cursor = null;
    try {
        cursor = database.query(TABLE_NAME, null, selection, selectionArgs, null, null, null);
        while (cursor != null && cursor.moveToNext()) {
            budgets.add(cursorToBudget(cursor));
        }
    } catch (Exception e) {
        LogUtils.e("Query budget by month error: " + e.getMessage());
    } finally {
        closeCursor(cursor);
    }
    
    return budgets;
}
```

#### 2.3.2 预算警告机制

- 当预算使用超过预警阈值时（默认80%）自动触发通知
- 使用Android的NotificationManager发送通知
- 支持自定义预警阈值

代码示例：
```java
public void checkBudgetWarning(Context context) {
    // 获取当前月份的所有预算
    Calendar calendar = Calendar.getInstance();
    int year = calendar.get(Calendar.YEAR);
    int month = calendar.get(Calendar.MONTH) + 1;
    
    List<Budget> budgets = databaseManager.getBudgetDao().queryByMonth(year, month);
    for (Budget budget : budgets) {
        // 获取预算进度
        getBudgetProgress(budget.getId(), new RepositoryCallback<BudgetProgress>() {
            @Override
            public void onSuccess(BudgetProgress progress) {
                // 检查是否超出预警阈值
                if (progress.getProgress() >= budget.getWarningThreshold() && !budget.isWarned()) {
                    // 发送通知
                    sendBudgetWarningNotification(context, progress);
                    
                    // 更新预算状态
                    budget.setWarned(true);
                    databaseManager.getBudgetDao().update(budget);
                }
            }
            
            @Override
            public void onError(String error) {
                LogUtils.e("Check budget warning error: " + error);
            }
        });
    }
}
```

### 2.4 统计报表模块

#### 2.4.1 核心功能与方法

**StatisticsRepository**
- `getMonthlyStatistics()`: 获取月度统计数据
- `getCategoryDistribution()`: 获取分类分布统计
- `getIncomeExpenseComparison()`: 获取收支对比统计
- `getTrends()`: 获取趋势分析数据
- `exportToExcel()`: 导出Excel报表

代码示例：
```java
public void getCategoryDistribution(long startTime, long endTime, int type, 
                                   RepositoryCallback<List<CategoryStatistic>> callback) {
    // 从本地数据库获取统计数据
    List<CategoryStatistic> statistics = databaseManager.getTransactionDao()
            .getCategoryStatistics(startTime, endTime, type);
    
    if (statistics.isEmpty()) {
        callback.onError("没有交易记录");
    } else {
        callback.onSuccess(statistics);
    }
}
```

**TransactionDao统计方法**
- `getSumByType()`: 根据类型获取交易总额
- `getSumByCategory()`: 根据分类获取交易总额
- `getCategoryStatistics()`: 获取分类统计
- `getMonthlyStatistics()`: 获取月度统计

代码示例：
```java
public List<CategoryStatistic> getCategoryStatistics(long startTime, long endTime, int type) {
    List<CategoryStatistic> result = new ArrayList<>();
    
    String sql = "SELECT c.id, c.name, c.color, SUM(t.amount) as total, COUNT(t.id) as count " +
            "FROM " + TABLE_NAME + " t " +
            "JOIN " + FinanceDatabaseHelper.TABLE_CATEGORIES + " c ON t.category_id = c.id " +
            "WHERE t.transaction_time BETWEEN ? AND ? AND t.type = ? " +
            "GROUP BY c.id " +
            "ORDER BY total DESC";
    
    String[] args = new String[]{
            String.valueOf(startTime),
            String.valueOf(endTime),
            String.valueOf(type)
    };
    
    Cursor cursor = null;
    try {
        cursor = database.rawQuery(sql, args);
        double grandTotal = getSumByType(startTime, endTime, type);
        
        while (cursor != null && cursor.moveToNext()) {
            CategoryStatistic statistic = new CategoryStatistic();
            statistic.setCategoryId(cursor.getLong(0));
            statistic.setCategoryName(cursor.getString(1));
            statistic.setCategoryColor(cursor.getString(2));
            statistic.setAmount(cursor.getDouble(3));
            statistic.setCount(cursor.getInt(4));
            
            // 计算百分比
            if (grandTotal > 0) {
                statistic.setPercentage(statistic.getAmount() / grandTotal * 100);
            }
            
            result.add(statistic);
        }
    } catch (Exception e) {
        LogUtils.e("Get category statistics error: " + e.getMessage());
    } finally {
        closeCursor(cursor);
    }
    
    return result;
}
```

#### 2.4.2 图表可视化

- 使用MPAndroidChart库实现各种图表
- 支持饼图、柱状图、折线图等多种图表类型
- 提供交互式图表操作

代码示例：
```java
private void setupCategoryPieChart(List<CategoryStatistic> statistics) {
    List<PieEntry> entries = new ArrayList<>();
    List<Integer> colors = new ArrayList<>();
    
    for (CategoryStatistic statistic : statistics) {
        entries.add(new PieEntry((float) statistic.getAmount(), statistic.getCategoryName()));
        colors.add(Color.parseColor(statistic.getCategoryColor()));
    }
    
    PieDataSet dataSet = new PieDataSet(entries, "");
    dataSet.setColors(colors);
    dataSet.setValueTextSize(14f);
    dataSet.setValueFormatter(new PercentFormatter(binding.categoryPieChart));
    
    PieData data = new PieData(dataSet);
    binding.categoryPieChart.setData(data);
    binding.categoryPieChart.setUsePercentValues(true);
    binding.categoryPieChart.getDescription().setEnabled(false);
    binding.categoryPieChart.setEntryLabelTextSize(12f);
    binding.categoryPieChart.setCenterText("分类占比");
    binding.categoryPieChart.setCenterTextSize(18f);
    binding.categoryPieChart.invalidate();
}
```

### 2.5 分类管理模块

#### 2.5.1 核心功能与方法

**CategoryRepository**
- `getCategoryList()`: 获取分类列表
- `addCategory()`: 添加分类
- `updateCategory()`: 更新分类
- `deleteCategory()`: 删除分类
- `getCategoryById()`: 根据ID获取分类

代码示例：
```java
public void getCategoryList(int type, final RepositoryCallback<List<Category>> callback) {
    // 先从本地数据库获取
    List<Category> localCategories = databaseManager.getCategoryDao().queryByType(type);
    
    // 如果本地有数据，直接返回
    if (!localCategories.isEmpty()) {
        callback.onSuccess(localCategories);
        return;
    }
    
    // 本地没有数据，从网络获取
    if (!NetworkUtils.isNetworkAvailable(context)) {
        callback.onError("无网络连接，无法获取分类");
        return;
    }
    
    // 发起网络请求
    apiService.getCategories(type).enqueue(new Callback<ApiResponse<List<Category>>>() {
        @Override
        public void onResponse(Call<ApiResponse<List<Category>>> call, Response<ApiResponse<List<Category>>> response) {
            if (response.isSuccessful() && response.body() != null) {
                ApiResponse<List<Category>> apiResponse = response.body();
                if (apiResponse.isSuccess()) {
                    List<Category> categories = apiResponse.getData();
                    
                    // 保存到本地数据库
                    for (Category category : categories) {
                        databaseManager.getCategoryDao().insert(category);
                    }
                    
                    callback.onSuccess(categories);
                } else {
                    callback.onError(apiResponse.getMessage());
                }
            } else {
                callback.onError("获取分类失败，请稍后重试");
            }
        }
        
        @Override
        public void onFailure(Call<ApiResponse<List<Category>>> call, Throwable t) {
            LogUtils.e(TAG, "获取分类失败", t);
            callback.onError("获取分类失败: " + t.getMessage());
        }
    });
}
```

**CategoryDao**
- `insert()`: 插入分类
- `update()`: 更新分类
- `delete()`: 删除分类
- `queryById()`: 根据ID查询分类
- `queryByType()`: 根据类型查询分类
- `queryAll()`: 查询所有分类

代码示例：
```java
public List<Category> queryByType(int type) {
    List<Category> categories = new ArrayList<>();
    String selection = type > 0 ? "type = ?" : null;
    String[] selectionArgs = type > 0 ? new String[]{String.valueOf(type)} : null;
    
    Cursor cursor = null;
    try {
        cursor = database.query(TABLE_NAME, null, selection, selectionArgs, null, null, "display_order ASC");
        while (cursor != null && cursor.moveToNext()) {
            categories.add(cursorToCategory(cursor));
        }
    } catch (Exception e) {
        LogUtils.e("Query category by type error: " + e.getMessage());
    } finally {
        closeCursor(cursor);
    }
    
    return categories;
}
```

#### 2.5.2 分类管理UI

**CategoryManageActivity**
- `initViews()`: 初始化视图
- `setupTabLayout()`: 设置Tab页
- `setupRecyclerView()`: 设置RecyclerView
- `addCategory()`: 添加分类
- `editCategory()`: 编辑分类
- `deleteCategory()`: 删除分类

代码示例：
```java
private void addCategory() {
    // 创建对话框
    View dialogView = getLayoutInflater().inflate(R.layout.dialog_edit_category, null);
    EditText etName = dialogView.findViewById(R.id.et_category_name);
    ImageView ivIcon = dialogView.findViewById(R.id.iv_category_icon);
    Button btnSelectIcon = dialogView.findViewById(R.id.btn_select_icon);
    Button btnSelectColor = dialogView.findViewById(R.id.btn_select_color);
    
    // 设置图标选择
    btnSelectIcon.setOnClickListener(v -> {
        // 显示图标选择对话框
        showIconSelectDialog(icon -> {
            selectedIcon = icon;
            ivIcon.setImageResource(IconUtils.getIconResourceId(this, icon));
        });
    });
    
    // 设置颜色选择
    btnSelectColor.setOnClickListener(v -> {
        // 显示颜色选择对话框
        showColorPickerDialog(color -> {
            selectedColor = color;
            btnSelectColor.setBackgroundColor(Color.parseColor(color));
        });
    });
    
    // 创建对话框
    AlertDialog dialog = new AlertDialog.Builder(this)
            .setTitle(R.string.add_category)
            .setView(dialogView)
            .setPositiveButton(R.string.save, (dialogInterface, i) -> {
                // 获取分类名称
                String name = etName.getText().toString().trim();
                if (TextUtils.isEmpty(name)) {
                    Toast.makeText(this, R.string.category_name_empty, Toast.LENGTH_SHORT).show();
                    return;
                }
                
                // 创建分类请求
                AddCategoryRequest request = new AddCategoryRequest();
                request.setName(name);
                request.setType(selectedType);
                request.setIcon(selectedIcon);
                request.setColor(selectedColor);
                
                // 添加分类
                categoryRepository.addCategory(request, new RepositoryCallback<Category>() {
                    @Override
                    public void onSuccess(Category category) {
                        Toast.makeText(CategoryManageActivity.this, R.string.add_category_success, Toast.LENGTH_SHORT).show();
                        refreshCategories();
                    }
                    
                    @Override
                    public void onError(String error) {
                        Toast.makeText(CategoryManageActivity.this, error, Toast.LENGTH_SHORT).show();
                    }
                });
            })
            .setNegativeButton(R.string.cancel, null)
            .create();
    
    dialog.show();
}
```

## 3. 模拟接口实现详解

### 3.1 模拟接口架构

整个应用的网络请求在开发阶段使用了模拟接口的方式，主要通过OkHttp的Interceptor机制实现。关键类和它们的作用如下：

1. **MockInterceptor**: 核心实现类，拦截网络请求并提供模拟响应
2. **ApiResponse<T>**: 统一的API响应封装类，包含状态码、消息和数据
3. **NetworkManager**: 网络管理类，负责创建和配置Retrofit实例
4. **各种API接口类**: 如UserApiService、TransactionApiService等

### 3.2 MockInterceptor实现原理

MockInterceptor实现了OkHttp的Interceptor接口，拦截所有网络请求，根据请求路径返回相应的模拟数据。

代码示例：
```java
public class MockInterceptor implements Interceptor {
    private static final String TAG = "MockInterceptor";
    private static final MediaType JSON = MediaType.parse("application/json; charset=utf-8");
    private final Gson gson = new GsonBuilder()
            .setDateFormat("MMM d, yyyy HH:mm:ss")
            .setLenient()
            .create();

    @Override
    public Response intercept(Chain chain) throws IOException {
        Request request = chain.request();
        String url = request.url().toString();
        String method = request.method();
        String path = request.url().encodedPath();

        LogUtils.d(TAG, "Mock intercepting: " + method + " " + url);

        // 根据不同的API路径返回不同的模拟数据
        if (path.contains("/api/login") || url.contains("/api/login")) {
            return createLoginResponse(request);
        } else if (path.contains("/api/register") || url.contains("/api/register")) {
            return createRegisterResponse(request);
        } else if (path.contains("/api/categories") || url.contains("/api/categories")) {
            return createCategoriesResponse(request);
        } 
        // 更多路径匹配...

        // 对于不模拟的请求，继续正常请求
        LogUtils.d(TAG, "Not mocking: " + url);
        return chain.proceed(request);
    }
    
    // 各种模拟响应方法...
}
```

### 3.3 登录响应模拟详解

以登录接口为例，说明模拟响应的实现方式：

```java
private Response createLoginResponse(Request request) {
    try {
        // 解析请求体，获取用户名和密码
        String requestBody = request.body() != null ? bodyToString(request.body()) : "";
        LoginRequest loginRequest = gson.fromJson(requestBody, LoginRequest.class);
        
        // 创建模拟用户
        User user = new User();
        user.setId(1);
        user.setUsername(loginRequest.getUsername());
        user.setName("管理员");
        user.setEmail("admin@example.com");
        user.setPhone("13800138000");
        user.setRole("admin");
        user.setLastLoginTime(new Date());
        
        // 创建登录响应
        LoginResponse responseData = new LoginResponse();
        responseData.setUser(user);
        
        // 生成随机token
        String token = UUID.randomUUID().toString();
        responseData.setToken(token);
        
        // 设置过期时间为当前时间 + 30天
        Calendar calendar = Calendar.getInstance();
        calendar.add(Calendar.DAY_OF_MONTH, 30);
        long expiryTime = calendar.getTimeInMillis();
        responseData.setExpiryTime(expiryTime);
        
        // 设置设备信息
        responseData.setDeviceInfo(loginRequest.getDeviceInfo());
        
        // 创建成功的API响应
        ApiResponse<LoginResponse> apiResponse = new ApiResponse<>();
        apiResponse.setCode(200);
        apiResponse.setMessage("操作成功");
        apiResponse.setData(responseData);
        
        String responseJson = gson.toJson(apiResponse);
        LogUtils.d("Mock login response: " + responseJson);
        
        // 构建响应
        return new Response.Builder()
                .code(200)
                .message("OK")
                .request(request)
                .protocol(Protocol.HTTP_1_1)
                .body(ResponseBody.create(JSON, responseJson))
                .addHeader("content-type", "application/json")
                .build();
    } catch (Exception e) {
        LogUtils.e(TAG, "创建登录响应时出错", e);
        return createErrorResponse(request, 500, "服务器内部错误");
    }
}
```

### 3.4 统计数据模拟实现

统计功能是应用的重要功能，这里展示如何模拟统计数据响应：

```java
private Response createStatisticsResponse(Request request) {
    String url = request.url().toString();
    
    // 处理月度消费统计请求
    if (url.contains("monthly")) {
        return createMonthlyStatisticsResponse(request);
    }
    
    // 处理分类分布统计请求
    if (url.contains("category-distribution")) {
        return createCategoryDistributionResponse(request);
    }
    
    // 处理收支对比统计请求
    if (url.contains("income-expense")) {
        return createIncomeExpenseResponse(request);
    }
    
    // 处理趋势分析统计请求
    if (url.contains("trends")) {
        return createTrendsResponse(request);
    }
    
    // 默认响应
    return createErrorResponse(request, 400, "不支持的统计类型");
}

private Response createCategoryDistributionResponse(Request request) {
    try {
        // 获取请求参数
        String typeParam = request.url().queryParameter("type");
        int type = TextUtils.isEmpty(typeParam) ? Transaction.TYPE_EXPENSE : Integer.parseInt(typeParam);
        
        List<CategoryStatistic> statistics = new ArrayList<>();
        
        // 创建模拟数据
        if (type == Transaction.TYPE_EXPENSE) {
            statistics.add(createCategoryStatistic(1, "餐饮", "#FF5722", 2500.0, 30));
            statistics.add(createCategoryStatistic(2, "购物", "#4CAF50", 1800.0, 15));
            statistics.add(createCategoryStatistic(3, "交通", "#2196F3", 800.0, 20));
            statistics.add(createCategoryStatistic(4, "住房", "#9C27B0", 3000.0, 1));
            statistics.add(createCategoryStatistic(5, "娱乐", "#FFC107", 1200.0, 8));
        } else {
            statistics.add(createCategoryStatistic(6, "工资", "#3F51B5", 8000.0, 1));
            statistics.add(createCategoryStatistic(7, "奖金", "#E91E63", 2000.0, 1));
            statistics.add(createCategoryStatistic(8, "理财", "#009688", 500.0, 2));
        }
        
        // 计算总额和百分比
        double total = 0;
        for (CategoryStatistic statistic : statistics) {
            total += statistic.getAmount();
        }
        
        for (CategoryStatistic statistic : statistics) {
            statistic.setPercentage(statistic.getAmount() / total * 100);
        }
        
        // 创建API响应
        ApiResponse<List<CategoryStatistic>> apiResponse = new ApiResponse<>();
        apiResponse.setCode(200);
        apiResponse.setMessage("操作成功");
        apiResponse.setData(statistics);
        
        String responseJson = gson.toJson(apiResponse);
        
        // 构建响应
        return new Response.Builder()
                .code(200)
                .message("OK")
                .request(request)
                .protocol(Protocol.HTTP_1_1)
                .body(ResponseBody.create(JSON, responseJson))
                .addHeader("content-type", "application/json")
                .build();
    } catch (Exception e) {
        LogUtils.e(TAG, "创建分类分布统计响应时出错", e);
        return createErrorResponse(request, 500, "服务器内部错误");
    }
}
```

### 3.5 网络层和模拟层的整合

整个网络请求流程是如何与模拟接口整合的：

1. **配置OkHttp客户端**

```java
private OkHttpClient createOkHttpClient() {
    OkHttpClient.Builder builder = new OkHttpClient.Builder();
    
    // 添加请求拦截器
    builder.addInterceptor(new RequestInterceptor());
    
    // 添加模拟响应拦截器
    if (BuildConfig.DEBUG) {
        builder.addInterceptor(new MockInterceptor());
    }
    
    // 设置超时
    builder.connectTimeout(30, TimeUnit.SECONDS);
    builder.readTimeout(30, TimeUnit.SECONDS);
    builder.writeTimeout(30, TimeUnit.SECONDS);
    
    return builder.build();
}
```

2. **创建Retrofit实例**

```java
private Retrofit createRetrofit() {
    return new Retrofit.Builder()
            .baseUrl(BuildConfig.API_BASE_URL)
            .client(createOkHttpClient())
            .addConverterFactory(GsonConverterFactory.create())
            .build();
}
```

3. **创建API服务**

```java
public UserApiService getUserApiService() {
    if (userApiService == null) {
        userApiService = retrofit.create(UserApiService.class);
    }
    return userApiService;
}
```

## 4. 技术亮点

### 4.1 安全设计与实现

#### 4.1.1 密码存储安全

使用SHA-256加盐哈希存储密码，保证即使数据库被攻破，密码也不会泄露：

```java
public static String hashPassword(String password, String salt) {
    try {
        MessageDigest md = MessageDigest.getInstance("SHA-256");
        md.update(salt.getBytes());
        byte[] bytes = md.digest(password.getBytes());
        StringBuilder sb = new StringBuilder();
        for (byte aByte : bytes) {
            sb.append(Integer.toString((aByte & 0xff) + 0x100, 16).substring(1));
        }
        return sb.toString();
    } catch (NoSuchAlgorithmException e) {
        LogUtils.e("SecurityUtils", "Hash password error", e);
        return "";
    }
}

public static String generateSalt() {
    SecureRandom random = new SecureRandom();
    byte[] salt = new byte[16];
    random.nextBytes(salt);
    return Base64.encodeToString(salt, Base64.DEFAULT);
}
```

#### 4.1.2 数据库加密

使用SQLCipher对本地数据库进行加密，防止数据泄露：

```java
public class DatabaseHelper extends SQLiteOpenHelper {
    private static final String DATABASE_NAME = "finance.db";
    private static final int DATABASE_VERSION = 1;
    private static final String DATABASE_PASSWORD = "your_secure_password_here";
    
    // ...
    
    @Override
    public void onCreate(SQLiteDatabase db) {
        // 创建用户表
        db.execSQL(CREATE_TABLE_USERS);
        
        // 创建交易记录表
        db.execSQL(CREATE_TABLE_TRANSACTIONS);
        
        // 创建分类表
        db.execSQL(CREATE_TABLE_CATEGORIES);
        
        // 创建预算表
        db.execSQL(CREATE_TABLE_BUDGETS);
        
        // 创建登录历史表
        db.execSQL(CREATE_TABLE_LOGIN_HISTORY);
        
        // 创建通知表
        db.execSQL(CREATE_TABLE_NOTIFICATIONS);
    }
    
    public static SQLiteDatabase openDatabase(Context context) {
        try {
            SQLiteDatabase.loadLibs(context);
            File dbFile = context.getDatabasePath(DATABASE_NAME);
            
            if (!dbFile.exists()) {
                dbFile.getParentFile().mkdirs();
                return SQLiteDatabase.openOrCreateDatabase(dbFile, DATABASE_PASSWORD, null);
            } else {
                return SQLiteDatabase.openDatabase(dbFile.getAbsolutePath(), DATABASE_PASSWORD, null, SQLiteDatabase.OPEN_READWRITE);
            }
        } catch (Exception e) {
            LogUtils.e("DatabaseHelper", "Open database error", e);
            throw new RuntimeException("数据库打开失败", e);
        }
    }
}
```

#### 4.1.3 JWT Token认证

使用JWT Token进行用户认证，支持有效期控制：

```java
public class TokenManager {
    private static final String TAG = "TokenManager";
    private static TokenManager instance;
    
    private String token;
    private long expiryTime;
    
    private TokenManager() {
        // 单例构造函数
    }
    
    public static synchronized TokenManager getInstance() {
        if (instance == null) {
            instance = new TokenManager();
        }
        return instance;
    }
    
    public void saveToken(String token, long expiryTime) {
        this.token = token;
        this.expiryTime = expiryTime;
    }
    
    public String getToken() {
        return token;
    }
    
    public boolean isLoggedIn() {
        return !TextUtils.isEmpty(token) && System.currentTimeMillis() < expiryTime;
    }
    
    public void clearToken() {
        this.token = null;
        this.expiryTime = 0;
    }
}
```

### 4.2 离线支持与数据同步

应用支持离线操作，当网络恢复时自动同步数据：

```java
public void syncLocalData() {
    // 检查网络
    if (!NetworkUtils.isNetworkAvailable(context)) {
        return;
    }
    
    // 获取本地未同步的交易记录
    List<Transaction> localTransactions = databaseManager.getTransactionDao()
            .queryBySyncState(Transaction.SYNC_STATE_LOCAL);
    
    for (Transaction transaction : localTransactions) {
        // 转换为请求对象
        AddTransactionRequest request = convertTransactionToRequest(transaction);
        
        // 发起同步请求
        apiService.addTransaction(request).enqueue(new Callback<ApiResponse<Transaction>>() {
            @Override
            public void onResponse(Call<ApiResponse<Transaction>> call, Response<ApiResponse<Transaction>> response) {
                if (response.isSuccessful() && response.body() != null && response.body().isSuccess()) {
                    // 更新本地记录同步状态
                    transaction.setSyncState(Transaction.SYNC_STATE_SYNCED);
                    databaseManager.getTransactionDao().update(transaction);
                    LogUtils.d(TAG, "同步交易记录成功: " + transaction.getId());
                } else {
                    LogUtils.e(TAG, "同步交易记录失败: " + transaction.getId());
                }
            }
            
            @Override
            public void onFailure(Call<ApiResponse<Transaction>> call, Throwable t) {
                LogUtils.e(TAG, "同步交易记录网络错误: " + transaction.getId(), t);
            }
        });
    }
}
```

### 4.3 高效的数据缓存机制

使用内存缓存 + 数据库缓存的双层缓存机制，提高应用性能：

```java
public class DataCacheManager {
    private static final String TAG = "DataCacheManager";
    private static DataCacheManager instance;
    
    // 用户缓存
    private Map<Long, User> userCache = new HashMap<>();
    
    // 分类缓存
    private Map<Integer, List<Category>> categoryCache = new HashMap<>();
    
    // 交易记录缓存，按月份缓存
    private Map<String, List<Transaction>> transactionCache = new HashMap<>();
    
    private DataCacheManager() {
        // 单例构造函数
    }
    
    public static synchronized DataCacheManager getInstance() {
        if (instance == null) {
            instance = new DataCacheManager();
        }
        return instance;
    }
    
    // 缓存用户
    public void cacheUser(User user) {
        if (user != null) {
            userCache.put(user.getId(), user);
        }
    }
    
    // 获取缓存用户
    public User getCachedUser(long userId) {
        return userCache.get(userId);
    }
    
    // 缓存分类列表
    public void cacheCategories(int type, List<Category> categories) {
        categoryCache.put(type, categories);
    }
    
    // 获取缓存分类列表
    public List<Category> getCachedCategories(int type) {
        return categoryCache.get(type);
    }
    
    // 构建交易记录缓存键
    private String buildTransactionCacheKey(int year, int month, int type) {
        return year + "-" + month + "-" + type;
    }
    
    // 缓存交易记录
    public void cacheTransactions(int year, int month, int type, List<Transaction> transactions) {
        String key = buildTransactionCacheKey(year, month, type);
        transactionCache.put(key, transactions);
    }
    
    // 获取缓存交易记录
    public List<Transaction> getCachedTransactions(int year, int month, int type) {
        String key = buildTransactionCacheKey(year, month, type);
        return transactionCache.get(key);
    }
    
    // 清除所有缓存
    public void clearAllCache() {
        userCache.clear();
        categoryCache.clear();
        transactionCache.clear();
        LogUtils.d(TAG, "清除所有缓存");
    }
    
    // 清除特定类型的缓存
    public void clearCache(String type) {
        switch (type) {
            case "user":
                userCache.clear();
                break;
            case "category":
                categoryCache.clear();
                break;
            case "transaction":
                transactionCache.clear();
                break;
        }
        LogUtils.d(TAG, "清除" + type + "缓存");
    }
}
```

### 4.4 交易记录自动分类

使用基于规则的引擎实现交易记录自动分类：

```java
public class AutoCategorizer {
    private static final String TAG = "AutoCategorizer";
    private List<CategoryRule> rules = new ArrayList<>();
    
    public AutoCategorizer(Context context) {
        // 加载规则
        loadRules(context);
    }
    
    private void loadRules(Context context) {
        // 从数据库或配置文件加载规则
        // 这里简化为硬编码规则
        rules.add(new CategoryRule("餐饮", "餐厅|饭店|食堂|外卖|美食|餐饮|吃饭|午餐|晚餐", 1));
        rules.add(new CategoryRule("购物", "购物|超市|商场|淘宝|京东|网购", 2));
        rules.add(new CategoryRule("交通", "公交|地铁|打车|出租|滴滴|高铁|火车|机票", 3));
        rules.add(new CategoryRule("住房", "房租|水电|物业|宽带|煤气|有线", 4));
        rules.add(new CategoryRule("娱乐", "电影|游戏|KTV|演唱会|旅游|景点", 5));
    }
    
    public long suggestCategory(String note, double amount) {
        if (TextUtils.isEmpty(note)) {
            return 0;
        }
        
        for (CategoryRule rule : rules) {
            if (matchesRule(note, rule.getPattern())) {
                LogUtils.d(TAG, "自动匹配到分类: " + rule.getCategoryName() + ", 备注: " + note);
                return rule.getCategoryId();
            }
        }
        
        return 0;
    }
    
    private boolean matchesRule(String note, String pattern) {
        String[] keywords = pattern.split("\\|");
        for (String keyword : keywords) {
            if (note.contains(keyword)) {
                return true;
            }
        }
        return false;
    }
    
    // 分类规则内部类
    private static class CategoryRule {
        private String categoryName;
        private String pattern;
        private long categoryId;
        
        public CategoryRule(String categoryName, String pattern, long categoryId) {
            this.categoryName = categoryName;
            this.pattern = pattern;
            this.categoryId = categoryId;
        }
        
        public String getCategoryName() {
            return categoryName;
        }
        
        public String getPattern() {
            return pattern;
        }
        
        public long getCategoryId() {
            return categoryId;
        }
    }
}

```

## 5. 后端服务器开发规划

为了替换项目开发阶段使用的模拟接口，需要开发真实的后端服务器。下面将分析整个项目用到的数据结构和接口，并设计相应的数据库表结构和API接口清单。

### 5.1 数据库设计

基于项目中的Model实体类和模拟接口的实现，设计以下MySQL数据库表结构：

#### 5.1.1 用户表(users)

```sql
CREATE TABLE `users` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT '用户ID',
  `username` varchar(50) NOT NULL COMMENT '用户名',
  `password` varchar(64) NOT NULL COMMENT '密码（SHA-256加密）',
  `salt` varchar(32) NOT NULL COMMENT '密码盐值',
  `nickname` varchar(50) DEFAULT NULL COMMENT '昵称',
  `name` varchar(50) DEFAULT NULL COMMENT '姓名',
  `email` varchar(100) DEFAULT NULL COMMENT '邮箱',
  `phone` varchar(20) DEFAULT NULL COMMENT '手机号',
  `role` varchar(20) NOT NULL DEFAULT 'user' COMMENT '角色（admin/user）',
  `created_at` bigint(20) NOT NULL COMMENT '创建时间戳',
  `updated_at` bigint(20) NOT NULL COMMENT '更新时间戳',
  `last_login_time` datetime DEFAULT NULL COMMENT '最后登录时间',
  `failed_attempts` int(11) NOT NULL DEFAULT '0' COMMENT '登录失败次数',
  `locked_until` datetime DEFAULT NULL COMMENT '锁定截止时间',
  `wechat` varchar(100) DEFAULT NULL COMMENT '微信号',
  `qq` varchar(20) DEFAULT NULL COMMENT 'QQ号',
  PRIMARY KEY (`id`),
  UNIQUE KEY `uk_username` (`username`),
  UNIQUE KEY `uk_phone` (`phone`),
  UNIQUE KEY `uk_email` (`email`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='用户表';
```

#### 5.1.2 登录历史表(login_history)

```sql
CREATE TABLE `login_history` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT '历史ID',
  `user_id` bigint(20) NOT NULL COMMENT '用户ID',
  `login_time` datetime NOT NULL COMMENT '登录时间',
  `ip_address` varchar(50) DEFAULT NULL COMMENT 'IP地址',
  `device_info` text COMMENT '设备信息',
  `success` tinyint(1) NOT NULL DEFAULT '1' COMMENT '是否成功',
  PRIMARY KEY (`id`),
  KEY `idx_user_id` (`user_id`),
  CONSTRAINT `fk_login_history_user` FOREIGN KEY (`user_id`) REFERENCES `users` (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='登录历史表';
```

#### 5.1.3 分类表(categories)

```sql
CREATE TABLE `categories` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT '分类ID',
  `name` varchar(50) NOT NULL COMMENT '分类名称',
  `type` tinyint(4) NOT NULL COMMENT '类型（1:支出,2:收入）',
  `icon` varchar(50) DEFAULT NULL COMMENT '图标',
  `color` varchar(20) DEFAULT NULL COMMENT '颜色代码',
  `user_id` bigint(20) DEFAULT NULL COMMENT '用户ID（NULL表示系统预设）',
  `display_order` int(11) NOT NULL DEFAULT '0' COMMENT '显示顺序',
  `created_at` bigint(20) NOT NULL COMMENT '创建时间戳',
  `updated_at` bigint(20) NOT NULL COMMENT '更新时间戳',
  PRIMARY KEY (`id`),
  KEY `idx_user_id` (`user_id`),
  KEY `idx_type` (`type`),
  CONSTRAINT `fk_categories_user` FOREIGN KEY (`user_id`) REFERENCES `users` (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='分类表';
```

#### 5.1.4 交易记录表(transactions)

```sql
CREATE TABLE `transactions` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT '交易ID',
  `user_id` bigint(20) NOT NULL COMMENT '用户ID',
  `category_id` bigint(20) NOT NULL COMMENT '分类ID',
  `amount` decimal(12,2) NOT NULL COMMENT '金额',
  `type` tinyint(4) NOT NULL COMMENT '类型（1:支出,2:收入）',
  `transaction_time` bigint(20) NOT NULL COMMENT '交易时间戳',
  `note` varchar(255) DEFAULT NULL COMMENT '备注',
  `image_path` varchar(255) DEFAULT NULL COMMENT '图片路径',
  `location` varchar(255) DEFAULT NULL COMMENT '位置',
  `sync_state` tinyint(4) NOT NULL DEFAULT '2' COMMENT '同步状态（1:本地,2:已同步）',
  `created_at` bigint(20) NOT NULL COMMENT '创建时间戳',
  `updated_at` bigint(20) NOT NULL COMMENT '更新时间戳',
  PRIMARY KEY (`id`),
  KEY `idx_user_id` (`user_id`),
  KEY `idx_category_id` (`category_id`),
  KEY `idx_transaction_time` (`transaction_time`),
  KEY `idx_type` (`type`),
  CONSTRAINT `fk_transactions_category` FOREIGN KEY (`category_id`) REFERENCES `categories` (`id`),
  CONSTRAINT `fk_transactions_user` FOREIGN KEY (`user_id`) REFERENCES `users` (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='交易记录表';
```

#### 5.1.5 预算表(budgets)

```sql
CREATE TABLE `budgets` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT '预算ID',
  `user_id` bigint(20) NOT NULL COMMENT '用户ID',
  `category_id` bigint(20) DEFAULT NULL COMMENT '分类ID（NULL表示总预算）',
  `year` int(11) NOT NULL COMMENT '年份',
  `month` int(11) NOT NULL COMMENT '月份',
  `amount` decimal(12,2) NOT NULL COMMENT '预算金额',
  `warning_threshold` decimal(5,2) NOT NULL DEFAULT '80.00' COMMENT '预警阈值（百分比）',
  `warned` tinyint(1) NOT NULL DEFAULT '0' COMMENT '是否已预警',
  `created_at` bigint(20) NOT NULL COMMENT '创建时间戳',
  `updated_at` bigint(20) NOT NULL COMMENT '更新时间戳',
  PRIMARY KEY (`id`),
  UNIQUE KEY `uk_user_category_year_month` (`user_id`,`category_id`,`year`,`month`),
  KEY `idx_category_id` (`category_id`),
  KEY `idx_year_month` (`year`,`month`),
  CONSTRAINT `fk_budgets_category` FOREIGN KEY (`category_id`) REFERENCES `categories` (`id`),
  CONSTRAINT `fk_budgets_user` FOREIGN KEY (`user_id`) REFERENCES `users` (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='预算表';
```

#### 5.1.6 通知表(notifications)

```sql
CREATE TABLE `notifications` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT '通知ID',
  `user_id` bigint(20) NOT NULL COMMENT '用户ID',
  `title` varchar(100) NOT NULL COMMENT '标题',
  `content` text NOT NULL COMMENT '内容',
  `type` varchar(20) NOT NULL COMMENT '类型（budget_warning/system_notice）',
  `read` tinyint(1) NOT NULL DEFAULT '0' COMMENT '是否已读',
  `created_at` bigint(20) NOT NULL COMMENT '创建时间戳',
  `updated_at` bigint(20) NOT NULL COMMENT '更新时间戳',
  PRIMARY KEY (`id`),
  KEY `idx_user_id` (`user_id`),
  KEY `idx_type` (`type`),
  KEY `idx_read` (`read`),
  CONSTRAINT `fk_notifications_user` FOREIGN KEY (`user_id`) REFERENCES `users` (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='通知表';
```

#### 5.1.7 分类规则表(category_rules)

```sql
CREATE TABLE `category_rules` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT '规则ID',
  `category_id` bigint(20) NOT NULL COMMENT '分类ID',
  `pattern` text NOT NULL COMMENT '匹配模式(关键词，以|分隔)',
  `user_id` bigint(20) DEFAULT NULL COMMENT '用户ID（NULL表示系统预设）',
  `created_at` bigint(20) NOT NULL COMMENT '创建时间戳',
  `updated_at` bigint(20) NOT NULL COMMENT '更新时间戳',
  PRIMARY KEY (`id`),
  KEY `idx_category_id` (`category_id`),
  KEY `idx_user_id` (`user_id`),
  CONSTRAINT `fk_category_rules_category` FOREIGN KEY (`category_id`) REFERENCES `categories` (`id`),
  CONSTRAINT `fk_category_rules_user` FOREIGN KEY (`user_id`) REFERENCES `users` (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='分类规则表';
```

#### 5.1.8 表关系说明

- **users表**: 核心用户表，存储用户基本信息和认证信息
- **login_history表**: 与users表是一对多关系，记录用户登录历史
- **categories表**: 存储交易分类，可以是系统预设或用户自定义
- **transactions表**: 核心交易记录表，与users和categories表是多对一关系
- **budgets表**: 与users和categories表关联，记录用户设置的预算信息
- **notifications表**: 存储系统通知和预算预警信息
- **category_rules表**: 存储自动分类规则，与categories表关联

#### 5.1.9 数据库设计修正说明

1. **时间字段类型**:
   - 大部分时间戳字段使用`bigint(20)`类型存储，与Android客户端保持一致
   - `last_login_time`和`locked_until`使用`datetime`类型，因为代码中使用了`Date`类型处理

2. **字段命名调整**:
   - 将交易记录表中的`image_url`改为`image_path`，与实体类中的字段名保持一致

3. **增加分类规则表**:
   - 新增`category_rules`表，支持自动分类功能的实现
   - 支持系统预设规则和用户自定义规则

### 5.2 API接口清单

根据项目中的模拟接口实现，整理出以下需要实现的API接口清单：

#### 5.2.1 用户模块接口

| 接口路径 | 方法 | 描述 | 参数 | 返回值 |
|---------|------|------|------|-------|
| /api/login | POST | 用户登录 | username, password, deviceInfo | token, expiryTime, user |
| /api/register | POST | 用户注册 | username, password, email, phone, verifyCode | 成功消息 |
| /api/user/{id} | GET | 获取用户信息 | userId | user |
| /api/user/{id} | PUT | 更新用户信息 | userId, nickname, email, phone, etc. | 更新后的user |
| /api/user/password | PUT | 修改密码 | oldPassword, newPassword | 成功消息 |
| /api/user/login-history | GET | 获取登录历史 | userId, pageNum, pageSize | 登录历史列表 |

#### 5.2.2 分类模块接口

| 接口路径 | 方法 | 描述 | 参数 | 返回值 |
|---------|------|------|------|-------|
| /api/categories | GET | 获取分类列表 | type | 分类列表 |
| /api/categories | POST | 添加分类 | name, type, icon, color | 新分类 |
| /api/categories/{id} | PUT | 更新分类 | id, name, icon, color | 更新后的分类 |
| /api/categories/{id} | DELETE | 删除分类 | id | 成功消息 |

#### 5.2.3 交易记录模块接口

| 接口路径 | 方法 | 描述 | 参数 | 返回值 |
|---------|------|------|------|-------|
| /api/transactions | GET | 获取交易记录列表 | userId, startDate, endDate, type, categoryId, pageNum, pageSize | 交易记录列表 |
| /api/transactions | POST | 添加交易记录 | userId, categoryId, amount, type, transactionTime, note, imageUrl | 新交易记录 |
| /api/transactions/{id} | GET | 获取交易记录详情 | id | 交易记录详情 |
| /api/transactions/{id} | PUT | 更新交易记录 | id, categoryId, amount, type, transactionTime, note, imageUrl | 更新后的交易记录 |
| /api/transactions/{id} | DELETE | 删除交易记录 | id | 成功消息 |

#### 5.2.4 预算模块接口

| 接口路径 | 方法 | 描述 | 参数 | 返回值 |
|---------|------|------|------|-------|
| /api/budgets | GET | 获取预算列表 | userId, year, month | 预算列表 |
| /api/budgets | POST | 添加预算 | userId, categoryId, year, month, amount, warningThreshold | 新预算 |
| /api/budgets/{id} | PUT | 更新预算 | id, amount, warningThreshold | 更新后的预算 |
| /api/budgets/{id} | DELETE | 删除预算 | id | 成功消息 |
| /api/budgets/{id}/progress | GET | 获取预算进度 | id | 预算进度信息 |

#### 5.2.5 统计模块接口

| 接口路径 | 方法 | 描述 | 参数 | 返回值 |
|---------|------|------|------|-------|
| /api/statistics/monthly | GET | 获取月度统计 | userId, year, month | 月度统计数据 |
| /api/statistics/category-distribution | GET | 获取分类分布 | userId, startDate, endDate, type | 分类分布数据 |
| /api/statistics/income-expense | GET | 获取收支对比 | userId, startDate, endDate | 收支对比数据 |
| /api/statistics/trends | GET | 获取趋势分析 | userId, startDate, endDate, type | 趋势数据 |

#### 5.2.6 通知模块接口

| 接口路径 | 方法 | 描述 | 参数 | 返回值 |
|---------|------|------|------|-------|
| /api/notifications | GET | 获取通知列表 | userId, read, pageNum, pageSize | 通知列表 |
| /api/notifications/count | GET | 获取未读通知数量 | userId | 未读数量 |
| /api/notifications/{id}/read | PUT | 标记通知为已读 | id | 成功消息 |
| /api/notifications/read-all | PUT | 标记所有通知为已读 | userId | 成功消息 |

### 5.3 后端实现建议

1. **技术选型**:
   - 框架: Spring Boot 2.x
   - ORM: MyBatis/MyBatis-Plus
   - 安全: Spring Security + JWT
   - 数据库: MySQL 8.x
   - 缓存: Redis

2. **安全实现**:
   - 密码加密: 使用与客户端一致的SHA-256加盐哈希
   - API认证: JWT Token认证，过期时间与客户端一致
   - 请求限流: 使用Redis实现API请求限流，防止恶意攻击

3. **性能优化**:
   - 查询缓存: 使用Redis缓存常用数据，如分类列表
   - 分页查询: 所有列表接口支持分页
   - 索引优化: 按照查询模式创建适当的索引

4. **数据同步**:
   - 提供批量同步接口，优化网络请求
   - 支持断点续传和增量同步
   - 使用乐观锁处理并发冲突

5. **开发步骤**:
   - 按照模块划分实现顺序: 用户模块 -> 分类模块 -> 交易记录模块 -> 预算模块 -> 统计模块 -> 通知模块
   - 每个模块实现Controller、Service、DAO三层结构
   - 优先实现核心业务功能，再实现辅助功能

通过以上数据库设计和API接口清单，后端开发人员可以清晰了解整个系统的数据结构和接口需求，快速开发出替代模拟接口的真实后端服务。
